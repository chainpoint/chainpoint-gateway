/**
 * Copyright 2019 Tierion
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let env = require('../parse-env.js').env
const errors = require('restify-errors')
const utils = require('../utils.js')
const uuidValidate = require('uuid-validate')
const uuidTime = require('uuid-time')
const chpBinary = require('chainpoint-binary')
const _ = require('lodash')
let cachedProofs = require('../cached-proofs.js')
let rocksDB = require('../models/RocksDB.js')
const logger = require('../logger.js')

// The custom MIME type for JSON proof array results containing Base64 encoded proof data
const BASE64_MIME_TYPE = 'application/vnd.chainpoint.json+base64'

// The custom MIME type for JSON proof array results containing Base64 encoded proof data
const JSONLD_MIME_TYPE = 'application/vnd.chainpoint.ld+json'

/**
 * Converts proof path array output from the merkle-tools package
 * to a Chainpoint v3 ops array
 *
 * @param {proof object array} proof - The proof array generated by merkle-tools
 * @param {string} op - The hash type performed throughout merkle tree construction (sha-256, sha-512, sha-256-x2, etc.)
 * @returns {ops object array}
 */
function formatAsChainpointV3Ops(proof, op) {
  let ChainpointV3Ops = proof.reduce((result, item) => {
    if (item.left) {
      item = { l: item.left }
    } else {
      item = { r: item.right }
    }
    result.push(item, { op: op })
    return result
  }, [])

  return ChainpointV3Ops
}

/**
 * GET /proofs/:proof_id handler
 *
 * Expects a path parameter 'proof_id' in the form of a Version 1 UUID
 *
 * Returns a chainpoint proof for the requested Proof ID
 */
async function getProofsByIDAsync(req, res, next) {
  res.contentType = 'application/json'

  let proofIds = []

  // check if proof_id parameter was included
  if (req.params && req.params.proof_id) {
    // a proof_id was specified in the url, so use that proof_id only

    if (!uuidValidate(req.params.proof_id, 1)) {
      return next(new errors.InvalidArgumentError('invalid request, bad proof_id'))
    }

    proofIds.push(req.params.proof_id)
  } else if (req.headers && req.headers.proofids) {
    // no proof_id was specified in url, read from headers.proofids
    proofIds = req.headers.proofids.split(',').map(_.trim)
  }

  // ensure at least one proof_id was submitted
  if (proofIds.length === 0) {
    return next(new errors.InvalidArgumentError('invalid request, at least one proof id required'))
  }

  // ensure that the request count does not exceed the maximum setting
  if (proofIds.length > env.GET_PROOFS_MAX) {
    return next(new errors.InvalidArgumentError('invalid request, too many proof ids (' + env.GET_PROOFS_MAX + ' max)'))
  }

  // ensure all proof_ids are valid
  for (let proofId of proofIds) {
    if (!uuidValidate(proofId, 1)) {
      return next(new errors.InvalidArgumentError('invalid request, bad proof_id'))
    }
  }

  let requestedType =
    req.accepts(JSONLD_MIME_TYPE) && !req.accepts(BASE64_MIME_TYPE) ? JSONLD_MIME_TYPE : BASE64_MIME_TYPE

  // retrieve all the nodeProofDataItems for the requested proofIds
  let nodeProofDataItems = []
  try {
    nodeProofDataItems = await rocksDB.getProofStatesBatchByProofIdsAsync(proofIds)
  } catch (error) {
    return next(new errors.InternalError('error retrieving node proof data items'))
  }

  // convert all proof state value to chpv3
  nodeProofDataItems = nodeProofDataItems.map(nodeProofDataItem => {
    if (nodeProofDataItem.proofState === null) return nodeProofDataItem
    nodeProofDataItem.proofState = formatAsChainpointV3Ops(nodeProofDataItem.proofState, 'sha-256')
    return nodeProofDataItem
  })

  // get an array of all unique core submission objects from the proof data items by submitId
  let knownSubmitIds = []
  let uniqueCoreSubmissions = nodeProofDataItems.reduce((result, val) => {
    // if the node data item was not found for that proofId, skip this item
    if (_.isNil(val.submission)) return result
    // add this submission object to the results if it is unique
    let submitId = val.submission.submitId
    if (!knownSubmitIds.includes(submitId)) {
      knownSubmitIds.push(submitId)
      result.push(val.submission)
    }
    return result
  }, [])

  // get proofs for each unique submitId
  let coreProofDataItems
  try {
    coreProofDataItems = await cachedProofs.getCachedCoreProofsAsync(uniqueCoreSubmissions)
  } catch (error) {
    logger.error(`Could not get proofs from Core : ${error.message}`)
    return next(new errors.InternalError('error retrieving proofs from Core'))
  }

  // assemble all Core proofs received into an object keyed by submitId
  coreProofDataItems = coreProofDataItems.reduce((results, coreProofDataItem) => {
    results[coreProofDataItem.submitId] = coreProofDataItem
    return results
  }, {})

  // build the resulting proofs from the collected data for each proof_id
  let results = []
  for (let nodeProofDataItem of nodeProofDataItems) {
    let submitId = nodeProofDataItem.submission ? nodeProofDataItem.submission.submitId : null
    let coreProof = coreProofDataItems[submitId] ? coreProofDataItems[submitId].proof : null

    let fullProof = null
    if (coreProof) {
      fullProof = buildFullProof(coreProof, nodeProofDataItem)
    }

    let proofResult = fullProof
    if (requestedType === BASE64_MIME_TYPE && fullProof) proofResult = chpBinary.objectToBase64Sync(fullProof)

    results.push({
      proof_id: nodeProofDataItem.proofId,
      proof: proofResult,
      anchors_complete: coreProofDataItems[submitId] ? coreProofDataItems[submitId].anchorsComplete : []
    })
  }

  res.send(results)
  return next()
}

function buildFullProof(coreProof, nodeProofDataItem) {
  if (!coreProof || !nodeProofDataItem) return null

  let fullProof = _.cloneDeep(coreProof)
  let coreBranches = _.cloneDeep(fullProof.branches)
  fullProof.proof_id = nodeProofDataItem.proofId
  fullProof.hash = nodeProofDataItem.hash
  fullProof.hash_received = utils.formatDateISO8601NoMs(new Date(parseInt(uuidTime.v1(nodeProofDataItem.proofId))))
  fullProof.branches[0].label = 'aggregator'
  fullProof.branches[0].ops = nodeProofDataItem.proofState
  fullProof.branches[0].branches = coreBranches
  return fullProof
}

module.exports = {
  getProofsByIDAsync: getProofsByIDAsync,
  // additional functions for testing purposes
  setRocksDB: db => {
    rocksDB = db
  },
  setCachedProofs: cp => {
    cachedProofs = cp
  },
  setENV: obj => {
    env = obj
  }
}
