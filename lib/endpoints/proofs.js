/**
 * Copyright 2019 Tierion
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let env = require('../parse-env.js')
const errors = require('restify-errors')
const utils = require('../utils.js')
const uuidValidate = require('uuid-validate')
const uuidTime = require('uuid-time')
const chpBinary = require('chainpoint-binary')
const _ = require('lodash')
let cachedProofs = require('../cached-proofs.js')
let eventMetrics = require('../event-metrics.js')
let rocksDB = require('../models/RocksDB.js')

// The custom MIME type for JSON proof array results containing Base64 encoded proof data
const BASE64_MIME_TYPE = 'application/vnd.chainpoint.json+base64'

// The custom MIME type for JSON proof array results containing Base64 encoded proof data
const JSONLD_MIME_TYPE = 'application/vnd.chainpoint.ld+json'

/**
 * Converts proof path array output from the merkle-tools package
 * to a Chainpoint v3 ops array
 *
 * @param {proof object array} proof - The proof array generated by merkle-tools
 * @param {string} op - The hash type performed throughout merkle tree construction (sha-256, sha-512, sha-256-x2, etc.)
 * @returns {ops object array}
 */
function formatAsChainpointV3Ops(proof, op) {
  let ChainpointV3Ops = proof.reduce((result, item) => {
    if (item.left) {
      item = { l: item.left }
    } else {
      item = { r: item.right }
    }
    result.push(item, { op: op })
    return result
  }, [])

  return ChainpointV3Ops
}

/**
 * GET /proofs/:hash_id handler
 *
 * Expects a path parameter 'hash_id' in the form of a Version 1 UUID
 *
 * Returns a chainpoint proof for the requested Hash ID
 */
async function getProofsByIDAsync(req, res, next) {
  res.contentType = 'application/json'

  let hashIds = []

  // check if hash_id parameter was included
  if (req.params && req.params.hash_id_node) {
    // a hash_id was specified in the url, so use that hash_id only

    if (!uuidValidate(req.params.hash_id_node, 1)) {
      return next(new errors.InvalidArgumentError('invalid request, bad hash_id'))
    }

    hashIds.push(req.params.hash_id_node)
  } else if (req.headers && req.headers.hashids) {
    // no hash_id was specified in url, read from headers.hashids
    hashIds = req.headers.hashids.split(',').map(_.trim)
  }

  // ensure at least one hash_id was submitted
  if (hashIds.length === 0) {
    return next(new errors.InvalidArgumentError('invalid request, at least one hash id required'))
  }

  // ensure that the request count does not exceed the maximum setting
  if (hashIds.length > env.GET_PROOFS_MAX_REST) {
    return next(
      new errors.InvalidArgumentError('invalid request, too many hash ids (' + env.GET_PROOFS_MAX_REST + ' max)')
    )
  }

  // ensure all hash_ids are valid
  for (let hashId of hashIds) {
    if (!uuidValidate(hashId, 1)) {
      return next(new errors.InvalidArgumentError('invalid request, bad hash_id'))
    }
  }

  // Increase proofsRetrieved event metric by hashIds.length
  eventMetrics.captureEvent('proofsRetrieved', hashIds.length)

  let requestedType =
    req.accepts(JSONLD_MIME_TYPE) && !req.accepts(BASE64_MIME_TYPE) ? JSONLD_MIME_TYPE : BASE64_MIME_TYPE

  // retrieve all the nodeProofDataItems for the requested hashIds
  let nodeProofDataItems = []
  try {
    nodeProofDataItems = await rocksDB.getProofStatesBatchByHashIdNodesAsync(hashIds)
  } catch (error) {
    return next(new errors.InternalError('error retrieving node proof data items'))
  }

  // convert all proof state value to chpv3
  nodeProofDataItems = nodeProofDataItems.map(nodeProofDataItem => {
    if (nodeProofDataItem.proofState === null) return nodeProofDataItem
    nodeProofDataItem.proofState.unshift({
      left: `node_id:${nodeProofDataItem.hashIdNode}`
    })
    nodeProofDataItem.proofState = formatAsChainpointV3Ops(nodeProofDataItem.proofState, 'sha-256')
    return nodeProofDataItem
  })

  // get an array of all unique hashIdCores in nodeProofDataItems the need to be retrieved
  let uniqueHashIdCores = nodeProofDataItems.reduce((result, val) => {
    if (!result.includes(val.hashIdCore) && val.hashIdCore != null) result.push(val.hashIdCore)
    return result
  }, [])

  // get proofs for each unique hash_id_core
  let coreProofDataItems
  try {
    coreProofDataItems = await cachedProofs.getCachedCoreProofsAsync(uniqueHashIdCores)
  } catch (error) {
    console.error(`ERROR : Could not get proofs from proofs.chainpoint.org : ${error.message}`)
    return next(new errors.InternalError('error retrieving proofs from proofs.chainpoint.org'))
  }

  // assemble all Core proofs received into an object keyed by hash_id_core
  coreProofDataItems = coreProofDataItems.reduce((results, coreProofDataItem) => {
    results[coreProofDataItem.hash_id] = coreProofDataItem
    return results
  }, {})

  // build the resulting proofs from the collected data for each hash_id_node
  let results = []
  for (let nodeProofDataItem of nodeProofDataItems) {
    let hashIdNode = nodeProofDataItem.hashIdNode
    let hashIdCore = nodeProofDataItem.hashIdCore
    let coreProof = coreProofDataItems[hashIdCore] ? coreProofDataItems[hashIdCore].proof : null

    let fullProof = null
    if (coreProof) {
      fullProof = buildFullProof(hashIdNode, hashIdCore, coreProof, nodeProofDataItem)
    }

    let proofResult = fullProof
    if (requestedType === BASE64_MIME_TYPE && fullProof) proofResult = chpBinary.objectToBase64Sync(fullProof)

    results.push({
      hash_id_node: hashIdNode,
      proof: proofResult,
      anchors_complete: coreProofDataItems[hashIdCore] ? coreProofDataItems[hashIdCore].anchorsComplete : []
    })
  }

  res.send(results)
  return next()
}

function buildFullProof(hashIdNode, hashIdCore, coreProof, nodeProofDataItem) {
  if (!coreProof || !nodeProofDataItem) return null

  let fullProofItem = {}
  fullProofItem.hash_id = nodeProofDataItem.hashIdNode
  let fullProof = _.cloneDeep(coreProof)
  fullProof.hash_id_node = nodeProofDataItem.hashIdNode
  fullProof.hash_submitted_node_at = utils.formatDateISO8601NoMs(
    new Date(parseInt(uuidTime.v1(fullProof.hash_id_node)))
  )
  fullProof.hash = nodeProofDataItem.hash
  for (let y = nodeProofDataItem.proofState.length - 1; y >= 0; y--) {
    fullProof.branches[0].ops.unshift(nodeProofDataItem.proofState[y])
  }
  fullProofItem.proof = fullProof
  return fullProofItem.proof
}

module.exports = {
  getProofsByIDAsync: getProofsByIDAsync,
  // additional functions for testing purposes
  setEventMetrics: em => {
    eventMetrics = em
  },
  setRocksDB: db => {
    rocksDB = db
  },
  setCachedProofs: cp => {
    cachedProofs = cp
  },
  setENV: obj => {
    env = obj
  }
}
