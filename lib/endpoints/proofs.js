/**
 * Copyright 2019 Tierion
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let env = require('../parse-env.js').env
const errors = require('restify-errors')
const utils = require('../utils.js')
const uuidValidate = require('uuid-validate')
const uuidTime = require('uuid-time')
const chpBinary = require('chainpoint-binary')
const _ = require('lodash')
let cachedProofs = require('../cached-proofs.js')
let rocksDB = require('../models/RocksDB.js')
const logger = require('../logger.js')
const analytics = require('../analytics.js')

// The custom MIME type for JSON proof array results containing Base64 encoded proof data
const BASE64_MIME_TYPE = 'application/vnd.chainpoint.json+base64'

// The custom MIME type for JSON proof array results containing Base64 encoded proof data
const JSONLD_MIME_TYPE = 'application/vnd.chainpoint.ld+json'

/**
 * Converts proof path array output from the merkle-tools package
 * to a Chainpoint v3 ops array
 *
 * @param {proof object array} proof - The proof array generated by merkle-tools
 * @param {string} op - The hash type performed throughout merkle tree construction (sha-256, sha-512, sha-256-x2, etc.)
 * @returns {ops object array}
 */
function formatAsChainpointV3Ops(proof, op) {
  let ChainpointV3Ops = proof.reduce((result, item) => {
    if (item.left) {
      item = { l: item.left }
    } else {
      item = { r: item.right }
    }
    result.push(item, { op: op })
    return result
  }, [])

  return ChainpointV3Ops
}

/**
 * GET /proofs/:proof_id handler
 *
 * Expects a path parameter 'proof_id' in the form of a Version 1 UUID
 *
 * Returns a chainpoint proof for the requested Proof ID
 */
async function getProofsByIDAsync(req, res, next) {
  res.contentType = 'application/json'
  let ip = utils.getClientIP(req)
  let proofIds = []

  // check if proof_id parameter was included
  if (req.params && req.params.proof_id) {
    // a proof_id was specified in the url, so use that proof_id only

    if (!uuidValidate(req.params.proof_id, 1)) {
      return next(new errors.InvalidArgumentError('invalid request, bad proof_id'))
    }

    proofIds.push(req.params.proof_id)
  } else if (req.headers && req.headers.proofids) {
    // no proof_id was specified in url, read from headers.proofids
    proofIds = req.headers.proofids.split(',').map(_.trim)
  }

  // ensure at least one proof_id was submitted
  if (proofIds.length === 0) {
    return next(new errors.InvalidArgumentError('invalid request, at least one proof id required'))
  }

  // ensure that the request count does not exceed the maximum setting
  if (proofIds.length > env.GET_PROOFS_MAX) {
    return next(new errors.InvalidArgumentError('invalid request, too many proof ids (' + env.GET_PROOFS_MAX + ' max)'))
  }

  // ensure all proof_ids are valid, send event
  for (let proofId of proofIds) {
    if (!uuidValidate(proofId, 1)) {
      return next(new errors.InvalidArgumentError('invalid request, bad proof_id'))
    }
    // Proof endpoint (always logged regardless of proof retrieval success)
    var startProofEvent = {
      ec: env.GATEWAY_NAME,
      ea: 'GetProof',
      el: proofId,
      cd1: 'Start',
      cd2: utils.formatDateISO8601NoMs(new Date()),
      cd3: env.PUBLIC_IP,
      cd4: ip,
      dp: '/proof'
    }
    analytics.setClientID(proofId)
    analytics.sendEvent(startProofEvent)
  }

  let requestedType =
    req.accepts(JSONLD_MIME_TYPE) && !req.accepts(BASE64_MIME_TYPE) ? JSONLD_MIME_TYPE : BASE64_MIME_TYPE

  // retrieve all the nodeProofDataItems for the requested proofIds
  let nodeProofDataItems = []
  try {
    nodeProofDataItems = await rocksDB.getProofStatesBatchByProofIdsAsync(proofIds)
  } catch (error) {
    return next(new errors.InternalError('error retrieving node proof data items'))
  }

  // convert all proof state value to chpv3
  nodeProofDataItems = nodeProofDataItems.map(nodeProofDataItem => {
    if (nodeProofDataItem.proofState === null) return nodeProofDataItem
    nodeProofDataItem.proofState = formatAsChainpointV3Ops(nodeProofDataItem.proofState, 'sha-256')
    return nodeProofDataItem
  })

  // get an array of all unique core submission objects from the proof data items by submitId
  let knownSubmitIds = []
  let uniqueCoreSubmissions = nodeProofDataItems.reduce((result, val) => {
    // if the node data item was not found for that proofId, skip this item
    if (_.isNil(val.submission)) return result
    // add this submission object to the results if it is unique
    let submitId = val.submission.submitId
    if (!knownSubmitIds.includes(submitId)) {
      knownSubmitIds.push(submitId)
      result.push(val.submission)
    }
    return result
  }, [])

  // get proofs for each unique submitId
  let coreProofDataItems
  try {
    coreProofDataItems = await cachedProofs.getCachedCoreProofsAsync(uniqueCoreSubmissions)
  } catch (error) {
    logger.error(`Could not get proofs from Core : ${error.message}`)
    return next(new errors.InternalError('error retrieving proofs from Core'))
  }

  // assemble all Core proofs received into an object keyed by submitId
  coreProofDataItems = coreProofDataItems.reduce((results, coreProofDataItem) => {
    results[coreProofDataItem.submitId] = coreProofDataItem
    return results
  }, {})

  // build the resulting proofs from the collected data for each proof_id
  let results = []
  for (let nodeProofDataItem of nodeProofDataItems) {
    let submitId = nodeProofDataItem.submission ? nodeProofDataItem.submission.submitId : null
    let coreProof = coreProofDataItems[submitId] ? coreProofDataItems[submitId].proof : null

    let fullProof = null
    if (coreProof) {
      fullProof = buildFullProof(coreProof, nodeProofDataItem)
    }

    let proofResult = fullProof
    if (requestedType === BASE64_MIME_TYPE && fullProof) proofResult = chpBinary.objectToBase64Sync(fullProof)

    let result = {
      proof_id: nodeProofDataItem.proofId,
      proof: proofResult,
      anchors_complete: coreProofDataItems[submitId] ? coreProofDataItems[submitId].anchorsComplete : []
    }
    results.push(result)

    //send events
    var event = {
      ec: env.GATEWAY_NAME,
      el: result.proof_id,
      cd1: result.proof ? result.proof.hash : 'null',
      cd2: utils.formatDateISO8601NoMs(new Date()),
      cd3: env.PUBLIC_IP,
      cd4: ip,
      dp: '/proof'
    }
    analytics.setClientID(result.proof_id)
    if (fullProof) {
      try {
        let proofString = JSON.stringify(fullProof)
        if (proofString.includes('btc') || proofString.includes('tbtc')) { // eslint-disable-line
          event.ea = 'GetProofSuccessBtc'
          analytics.sendEvent(event)
        } else if (proofString.includes('cal') || proofString.includes('tcal')) { // eslint-disable-line
          event.ea = 'GetProofSuccessCal'
          analytics.sendEvent(event)
        }
      } catch (error) {
        logger.error(`could not get proof size of proof ${result.proof_id}`)
      }
    } else {
      event.ea = 'GetProofFail'
      analytics.sendEvent(event)
    }
  }

  res.send(results)
  return next()
}

function buildFullProof(coreProof, nodeProofDataItem) {
  if (!coreProof || !nodeProofDataItem) return null

  let fullProof = _.cloneDeep(coreProof)
  let coreBranches = _.cloneDeep(fullProof.branches)
  fullProof.proof_id = nodeProofDataItem.proofId
  fullProof.hash = nodeProofDataItem.hash
  fullProof.hash_received = utils.formatDateISO8601NoMs(new Date(parseInt(uuidTime.v1(nodeProofDataItem.proofId))))
  fullProof.branches[0].label = 'aggregator'
  fullProof.branches[0].ops = nodeProofDataItem.proofState
  fullProof.branches[0].branches = coreBranches
  return fullProof
}

module.exports = {
  getProofsByIDAsync: getProofsByIDAsync,
  // additional functions for testing purposes
  setRocksDB: db => {
    rocksDB = db
  },
  setCachedProofs: cp => {
    cachedProofs = cp
  },
  setENV: obj => {
    env = obj
  }
}
